***(
  core of the tool
  @author: duongtd
)

in ipsg_lms_handling.maude
--- temp, should be enable if test only Maude code in this file
--- set print attribute on .

***(
  principle sort CheckResult, which is used in some other modules,
  somewhat like ResultPair,
  e.g, find Constant from a term
)
fmod TERM-CHECK-RESULT is
  pr META-TERM .

  sort CheckResult .
  
  op checkResult : Term Bool -> CheckResult [ctor] . 
  op getCheckResultTerm : CheckResult -> Term .
  op getCheckResultBool : CheckResult -> Bool .

  var T1 : Term .
  var B1 : Bool .

  eq getCheckResultTerm(checkResult(T1, B1)) = T1 .
  eq getCheckResultBool(checkResult(T1, B1)) = B1 .
endfm

view CheckResult from TRIV to TERM-CHECK-RESULT is
  sort Elt to CheckResult .
endv

fmod TERM-CHECK-RESULT-LIST is
  protecting LIST{CheckResult} * 
  (sort NeList{CheckResult} to NeCheckResultList, 
   sort List{CheckResult} to CheckResultList) .
endfm

***(
  parse term returned by metaParse of Maude
  e.g, extractIfCondsT, extractSplitCasesT
)
fmod PARSE-TERM is
  pr LIST-UTILS .
  pr MAP{Term, Nat} * 
    (sort Map{Term, Nat} to MapTermNat, 
      sort Entry{Term, Nat} to EntryTermNat) .
  
  op extractIfCondsTL : TermList -> TermList .
  op extractIfCondsT : Term -> TermList .
  op extractLeftEq : Term -> Term .
  op extractRightEq : Term -> Term .
  op extractSplitCasesT : Term -> TermList .
  op extractSplitCasesTL : TermList -> TermList .

  vars TE TE1 TE2 TE3 : Term .
  vars TY TY1 TY2 : Type .
  vars TELIST TELIST1 TELIST2 : TermList .
  vars QI QI1 : Qid .

  eq extractIfCondsTL(empty) = empty .
  eq extractIfCondsTL((TE , TELIST)) = 
      appendList(extractIfCondsT(TE), extractIfCondsTL(TELIST)) .
  eq extractIfCondsT('if_then_else_fi[TE1, TE2, TE3]) = 
      (if extractIfCondsT(TE1) == empty then
        appendList(
          headTL(extractSplitCasesT(TE1)), 
          appendList(extractIfCondsT(TE2), 
          extractIfCondsT(TE3))) 
      else
        appendList(extractIfCondsT(TE1), appendList(extractIfCondsT(TE2), extractIfCondsT(TE3))) 
      fi) .
  eq extractIfCondsT('_xor_[TE1, TELIST]) = 
      appendList(extractIfCondsT(TE1), extractIfCondsTL(TELIST)) .
  eq extractIfCondsT('_and_[TE1, TELIST]) = 
      appendList(extractIfCondsT(TE1), extractIfCondsTL(TELIST)) .
  eq extractIfCondsT('_or_[TE1, TELIST]) = 
      appendList(extractIfCondsT(TE1), extractIfCondsTL(TELIST)) .
  eq extractIfCondsT('_=_[TE1, TE2]) = 
      appendList(extractIfCondsT(TE1), extractIfCondsT(TE2)) .
  eq extractIfCondsT(QI[TE1, TELIST]) = 
      appendList(extractIfCondsT(TE1), extractIfCondsTL(TELIST)) .
  eq extractIfCondsT(TE) = empty [owise] .

  eq extractLeftEq('_=_[TE1, TE2]) = TE1 .
  eq extractRightEq('_=_[TE1, TE2]) = TE2 .

  eq extractSplitCasesTL((TE , TELIST)) = 
      appendList(extractSplitCasesT(TE), extractSplitCasesTL(TELIST)) .
  eq extractSplitCasesT('_xor_[TE1, TELIST]) = 
      appendList(extractSplitCasesT(TE1), extractSplitCasesTL(TELIST)) .
  eq extractSplitCasesT('_and_[TE1, TELIST]) = 
      appendList(extractSplitCasesT(TE1), extractSplitCasesTL(TELIST)) .
  eq extractSplitCasesT('_or_[TE1, TELIST]) = 
      appendList(extractSplitCasesT(TE1), extractSplitCasesTL(TELIST)) .
  
  eq extractSplitCasesT('_=_['false.Bool, TE1]) = extractSplitCasesT(TE1) .
  eq extractSplitCasesT('_=_[TE1, 'false.Bool]) = extractSplitCasesT(TE1) .

  eq extractSplitCasesT('_=_[TE1, TE2]) = 
    if (extractSplitCasesT(TE1) == empty or extractSplitCasesT(TE1) == TE1) and 
      (extractSplitCasesT(TE2) == empty or extractSplitCasesT(TE2) == TE2) then
      '_=_[TE1, TE2]
    else
      appendList(extractSplitCasesT(TE1), extractSplitCasesTL(TE2)) 
    fi .
  eq extractSplitCasesT(TE) = 
    if TE == 'true.Bool or TE == 'false.Bool then
      empty
    else
      TE 
    fi .
  eq extractSplitCasesTL(empty) = empty .

  op extractIfCondsTL2 : TermList -> MapTermNat .
  op doExtractIfCondsTL2 : TermList MapTermNat -> MapTermNat .
  op extractIfCondsT2 : Term -> MapTermNat .
  op doExtractIfCondsT2 : Term MapTermNat -> MapTermNat .
  op extractSplitCasesT2 : Term -> MapTermNat .
  op doExtractSplitCasesT2 : Term MapTermNat -> MapTermNat .
  op extractSplitCasesTL2 : TermList -> MapTermNat .
  op doExtractSplitCasesTL2 : TermList MapTermNat -> MapTermNat .

  vars MTN1 MTN2 : MapTermNat .
  vars N1 N2 : Nat .

  eq extractIfCondsTL2(TELIST) = doExtractIfCondsTL2(TELIST, empty) .
  eq doExtractIfCondsTL2(empty, MTN1) = MTN1 .
  eq doExtractIfCondsTL2(TE1, MTN1) = doExtractIfCondsT2(TE1, MTN1) .
  ceq doExtractIfCondsTL2((TE , TELIST), MTN1) = 
      doExtractIfCondsTL2(TELIST, doExtractIfCondsT2(TE, MTN1))
    if TELIST =/= empty .
  
  eq extractIfCondsT2(TE1) = doExtractIfCondsT2(TE1, empty) .
  ceq doExtractIfCondsT2('if_then_else_fi[TE1, TE2, TE3], MTN1) = 
      (if MTN2 == MTN1 then
        doExtractIfCondsT2(TE3, 
          doExtractIfCondsT2(TE2, doExtractSplitCasesT2(TE1, MTN1)))
      else
        doExtractIfCondsT2(TE3, 
          doExtractIfCondsT2(TE2, MTN2)) 
      fi)
    if MTN2 := doExtractIfCondsT2(TE1, MTN1) .
  eq doExtractIfCondsT2(QI[TE1, TELIST], MTN1) = 
    doExtractIfCondsTL2(TELIST, doExtractIfCondsT2(TE1, MTN1)) .
  eq doExtractIfCondsT2(TE, MTN1) = MTN1 [owise] .

--- splitting case
  eq extractSplitCasesTL2(TELIST) = doExtractSplitCasesTL2(TELIST, empty) .
  eq doExtractSplitCasesTL2(empty, MTN1) = MTN1 .
  eq doExtractSplitCasesTL2(TE1, MTN1) = doExtractSplitCasesT2(TE1, MTN1) .
  ceq doExtractSplitCasesTL2((TE , TELIST), MTN1) = 
      doExtractSplitCasesTL2(TELIST, doExtractSplitCasesT2(TE, MTN1))
    if TELIST =/= empty .

---
  eq extractSplitCasesT2(TE1) = doExtractSplitCasesTL2(TE1, empty) . 
  eq doExtractSplitCasesT2('_xor_[TE1, TELIST], MTN1) = 
    doExtractSplitCasesTL2(TELIST, doExtractSplitCasesT2(TE1, MTN1)) .
  eq doExtractSplitCasesT2('_and_[TE1, TELIST], MTN1) = 
    doExtractSplitCasesTL2(TELIST, doExtractSplitCasesT2(TE1, MTN1)) .
  eq doExtractSplitCasesT2('_or_[TE1, TELIST], MTN1) = 
    doExtractSplitCasesTL2(TELIST, doExtractSplitCasesT2(TE1, MTN1)) .
  
  eq doExtractSplitCasesT2('_=_['false.Bool, TE1], MTN1) = 
    doExtractSplitCasesT2(TE1, MTN1) .
  eq doExtractSplitCasesT2('_=_[TE1, 'false.Bool], MTN1) = 
    doExtractSplitCasesT2(TE1, MTN1) .

  eq doExtractSplitCasesT2('_=_[TE1, TE2], MTN1) = 
    if doExtractSplitCasesT2(TE1, MTN1) == MTN1 and 
      doExtractSplitCasesT2(TE2, MTN1) == MTN1 then
      if MTN1['_=_[TE1, TE2]] :: Nat then
        insert('_=_[TE1, TE2], MTN1['_=_[TE1, TE2]] + 1, MTN1)
      else
        insert('_=_[TE1, TE2], 1, MTN1)
      fi
    else
      doExtractSplitCasesT2(TE2, doExtractSplitCasesT2(TE1, MTN1)) 
    fi .
  eq doExtractSplitCasesT2(TE1, MTN1) = MTN1 [owise] .


  op chooseBestTerm : MapTermNat -> Term .
  op doChooseBestTerm : MapTermNat Term Nat -> Term .
  eq chooseBestTerm(TE1 |-> N1) = TE1 .
  eq chooseBestTerm((TE1 |-> N1, MTN1)) = doChooseBestTerm(MTN1, TE1, N1) .
  eq doChooseBestTerm(TE1 |-> N1, TE2, N2) = 
    if N1 < N2 then
      TE2
    else
      TE1
    fi .
  eq doChooseBestTerm((TE1 |-> N1, MTN1), TE2, N2) =
    if N1 < N2 then
      doChooseBestTerm(MTN1, TE2, N2)
    else
      doChooseBestTerm(MTN1, TE1, N1)
    fi .
endfm

***(
  handle equations for case splitting
)
fmod HANDLE-EQS-CS is 
  --- pr META-LEVEL .
  pr TERM-CHECK-RESULT .
  pr LIST-UTILS .
  pr TERM-UTILS .
  pr TERM-ANALYSIS .

  vars TE1 TE2 TE3 TE4 : Term .
  vars TL1 TL2 : TermList .
  vars C1 C2 : Constant .
  vars Q1 Q2 : Qid .
  vars MOD PRSCMOD : Module .
  vars OP1 OP2 : OpDecl .
  vars OPS : OpDeclSet .
  vars ATTS1 ATTS2 : AttrSet .
  vars TYL : TypeList .
  vars TY1 TY2 : Type .
  vars N N2 : Nat .
  vars EQS1 EQS2 : EquationSet .
  vars EQ1 EQ2 : Equation .
  vars ATTR1 ATTR2 : AttrSet .

  op makeEqT : Term Module Module -> Equation .
  op makeEqT2 : Term Module Module -> Equation .
  op makeEqT3 : Term Module Module -> Equation .
  --- eq makeEqT('_=_[TE1, 'true.Bool], MOD) = (eq TE1 = 'true.Bool [none] .) .
  --- eq makeEqT('_=_['true.Bool, TE1], MOD) = (eq TE1 = 'true.Bool [none] .) .
  --- eq makeEqT('_=_[TE1, 'false.Bool], MOD) = (eq TE1 = 'true.Bool [none] .) .
  --- eq makeEqT('_=_['false.Bool, TE1], MOD) = (eq TE1 = 'true.Bool [none] .) .
  eq makeEqT('_=_[TE1, TE2], MOD, PRSCMOD) = 
    if TE1 == 'true.Bool or TE1 == 'false.Bool then
      (eq TE2 = 'true.Bool [none] .)
    else 
      if TE2 == 'true.Bool or TE2 == 'false.Bool then
        (eq TE1 = 'true.Bool [none] .)
      else
        makeEqT2('_=_[TE1, TE2], MOD, PRSCMOD)
      fi
    fi .
  eq makeEqT(TE1, MOD, PRSCMOD) 
    = (eq TE1 = 'true.Bool [none] .) [owise] .
  --- ceq makeEqF('_=_[TE1, TE2], MOD) = (eq TE2 = TE1 [none] .)
  ---   if isConstructorT(TE1, getOps(MOD), MOD) .
  --- ceq makeEqF('_=_[TE1, TE2], MOD) = (eq TE1 = TE2 [none] .)
  ---   if isConstructorT(TE2, getOps(MOD), MOD) .
  eq makeEqT2('_=_[TE1, TE2], MOD, PRSCMOD) =
    if isConstructorT(TE1, getOps(MOD), MOD) then
      (eq TE2 = TE1 [none] .)
    else
      if isConstructorT(TE2, getOps(MOD), MOD) then
        (eq TE1 = TE2 [none] .)
      else
        makeEqT3('_=_[TE1, TE2], MOD, PRSCMOD)
      fi
    fi .
  eq makeEqT3('_=_[C1, C2], MOD, PRSCMOD) = handleMakeEqTCs(C1, C2, MOD, PRSCMOD) .
  eq makeEqT3('_=_[TE1, C2], MOD, PRSCMOD) = (eq TE1 = C2 [none] .) .
  eq makeEqT3('_=_[C1, TE2], MOD, PRSCMOD) = (eq TE2 = C1 [none] .) .
  eq makeEqT3('_=_[TE1, TE2], MOD, PRSCMOD) = 
    (if checkExist(TE1, TE2) then
      (eq TE2 = TE1 [none] .) 
    else 
      --- (eq TE1 = TE2 [none] .) 
      handleMakeEqTTs(TE1, TE2, MOD, PRSCMOD)
    fi) .
  eq makeEqT3(TE1, MOD, PRSCMOD) = (eq TE1 = 'true.Bool [none] .) [owise] .

  op makeEqF : Term Module Module -> Equation .
  op makeEqF2 : Term Module Module -> Equation .
  op makeEqF3 : Term Module Module -> Equation .
  --- eq makeEqF('_=_[TE1, 'true.Bool], MOD) = (eq TE1 = 'false.Bool [none] .) .
  --- eq makeEqF('_=_['true.Bool, TE1], MOD) = (eq TE1 = 'false.Bool [none] .) .
  --- eq makeEqF('_=_[TE1, 'false.Bool], MOD) = (eq TE1 = 'false.Bool [none] .) .
  --- eq makeEqF('_=_['false.Bool, TE1], MOD) = (eq TE1 = 'false.Bool [none] .) .
  eq makeEqF('_=_[TE1, TE2], MOD, PRSCMOD) = 
    if TE1 == 'true.Bool or TE1 == 'false.Bool then
      (eq TE2 = 'false.Bool [none] .)
    else 
      if TE2 == 'true.Bool or TE2 == 'false.Bool then
        (eq TE1 = 'false.Bool [none] .)
      else
        makeEqF2('_=_[TE1, TE2], MOD, PRSCMOD)
      fi
    fi .
  eq makeEqF(TE1, MOD, PRSCMOD) = (eq TE1 = 'false.Bool [none] .) [owise] .
  --- ceq makeEqF('_=_[TE1, TE2], MOD) = (eq '_=_[TE2, TE1] = 'false.Bool [none] .)
  ---   if isConstructorT(TE1, getOps(MOD), MOD) [print "253"] .
  --- ceq makeEqF('_=_[TE1, TE2], MOD) = (eq '_=_[TE1, TE2] = 'false.Bool [none] .)
  ---   if isConstructorT(TE2, getOps(MOD), MOD) [print "255"] .
  eq makeEqF2('_=_[TE1, TE2], MOD, PRSCMOD) =
    if isConstructorT(TE1, getOps(MOD), MOD) then
      (eq '_=_[TE2, TE1] = 'false.Bool [none] .)
    else
      if isConstructorT(TE2, getOps(MOD), MOD) then
        (eq '_=_[TE1, TE2] = 'false.Bool [none] .)
      else
        makeEqF3('_=_[TE1, TE2], MOD, PRSCMOD)
      fi
    fi .
  eq makeEqF3('_=_[C1, C2], MOD, PRSCMOD) = handleMakeEqFCs(C1, C2, MOD, PRSCMOD) .
  eq makeEqF3('_=_[TE1, C2], MOD, PRSCMOD) = (eq '_=_[TE1, C2] = 'false.Bool [none] .) .
  eq makeEqF3('_=_[C1, TE2], MOD, PRSCMOD) = (eq '_=_[TE2, C1] = 'false.Bool [none] .) .
  eq makeEqF3('_=_[TE1, TE2], MOD, PRSCMOD) = 
    (if checkExist(TE1, TE2) then
      (eq '_=_[TE2, TE1] = 'false.Bool [none] .)
    else
      --- (eq '_=_[TE1, TE2] = 'false.Bool [none] .)
      handleMakeEqFTs(TE1, TE2, MOD, PRSCMOD)
    fi) .
  eq makeEqF3(TE1, MOD, PRSCMOD) = (eq TE1 = 'false.Bool [none] .) [owise] .

***(
  making equations between two constant based on constructor
  e.g., 0 = i should be converted to i = 0 since 0 is a ctor
)
  op handleMakeEqTCs : Constant Constant Module Module -> Equation .
  op handleMakeEqFCs : Constant Constant Module Module -> Equation .

***(
  auxiliary function
)
  op isConstructor : Constant OpDeclSet -> Bool .
  eq isConstructor(C1, none) = false .
  eq isConstructor(C1, op Q1 : nil -> TY1 [ATTS1 ctor ATTS2] . OPS) =
    if getName(C1) == Q1 then
      true
    else 
      isConstructor(C1, OPS)
    fi .
  eq isConstructor(C1, OP1 OPS) = isConstructor(C1, OPS) [owise] .

  eq handleMakeEqTCs(C1, C2, MOD, PRSCMOD) = 
    if isConstructor(C1, getOps(MOD)) then
      (eq C2 = C1 [none] .)
    else
      if isConstructor(C2, getOps(MOD)) then
        (eq C1 = C2 [none] .)
      else
        handleMakeEqTTs(C1, C2, MOD, PRSCMOD)
      fi
    fi .
  
  eq handleMakeEqFCs(C1, C2, MOD, PRSCMOD) = 
    if isConstructor(C1, getOps(MOD)) then
      (eq '_=_[C2, C1] = 'false.Bool [none] .) 
    else
      if isConstructor(C2, getOps(MOD)) then
        (eq '_=_[C1, C2] = 'false.Bool [none] .)
      else
        handleMakeEqFTs(C1, C2, MOD, PRSCMOD)
      fi
    fi .

***(
  making equations between two terms based on constructor
  e.g., s(place(s,r)) = place(s,p) should be converted to 
    place(s,p) = s(place(s,r)) since s(SNat) is a ctor
)
  op handleMakeEqTTs : Term Term Module Module -> Equation .
  op handleMakeEqFTs : Term Term Module Module -> Equation .

***(
  auxiliary function
)
  op isConstructorT : Term OpDeclSet Module -> Bool .
  eq isConstructorT(TE1, none, MOD) = false .
  eq isConstructorT(Q1[TL1], op Q1 : TYL -> TY1 [ATTS1 ctor ATTS2] . OPS, MOD) =
    if checkMatchTermL(TL1, TYL, MOD) then
      true
    else 
      isConstructorT(Q1[TL1], OPS, MOD)
    fi .
  eq isConstructorT(TE1, OP1 OPS, MOD) = isConstructorT(TE1, OPS, MOD) .

  op checkMatchTermL : TermList TypeList Module -> Bool .
  eq checkMatchTermL(empty, (nil).TypeList, MOD) = true .
  eq checkMatchTermL((TE1 , TL1), TY1 TYL, MOD) =
    if wellFormed(MOD, qid("VAR:" + string(TY1)) <- TE1) then
      checkMatchTermL(TL1, TYL, MOD)
    else
      false
    fi .
  eq checkMatchTermL(TL1, TYL, MOD) = false [owise] .
  
  eq handleMakeEqTTs(TE1, TE2, MOD, PRSCMOD) = 
    if isConstructorT(TE1, getOps(MOD), MOD) then
      (eq TE2 = TE1 [none] .)
    else
      if isConstructorT(TE2, getOps(MOD), MOD) then
        (eq TE1 = TE2 [none] .)
      else
        if checkTermExistEqs(TE1, getEqs(PRSCMOD)) and
            not(checkTermExistEqs(TE2, getEqs(PRSCMOD))) then
          (eq TE2 = TE1 [none] .)
        else
          (eq TE1 = TE2 [none] .)
        fi
      fi
    fi .

  eq handleMakeEqFTs(TE1, TE2, MOD, PRSCMOD) = 
    if isConstructorT(TE1, getOps(MOD), MOD) then
      (eq '_=_[TE2, TE1] = 'false.Bool [none] .) 
    else 
      if isConstructorT(TE2, getOps(MOD), MOD) then
        (eq '_=_[TE1, TE2] = 'false.Bool [none] .)
      else
        if checkTermExistEqs(TE1, getEqs(PRSCMOD)) and
            not(checkTermExistEqs(TE2, getEqs(PRSCMOD))) then
          (eq '_=_[TE2, TE1] = 'false.Bool [none] .) 
        else
          (eq '_=_[TE1, TE2] = 'false.Bool [none] .)
        fi
      fi
    fi .

--- check a term exist in a set of equations
  op checkTermExistEqs : Term EquationSet -> Bool .
  eq checkTermExistEqs(TE1, (none).EquationSet) = false .
  eq checkTermExistEqs(TE1, (eq TE2 = TE3 [ATTR1] . EQS1))
    = if checkExist(TE1, TE2) then
        true
      else
        if checkExist(TE1, TE3) then
          true
        else
          checkTermExistEqs(TE1, EQS1)
        fi
      fi .

***(
  choose a term to apply case splitting from a list of term
  higher priority on the simple term, e.g.,
  Q1.Constant = Q2.Constant will be chosen instead of
  TERM = Q2.Constant, where TERM is not a constant.
)
  op chooseTermCS : TermList -> Term .

--- find Constant = Constant
  op findTermCeqC : TermList -> CheckResult .

--- find Term = Constant
  op findTermTeqC : TermList -> CheckResult .

  eq findTermCeqC(empty) = checkResult('false.Bool, false) .
  eq findTermCeqC(('_=_[C1, C2], TL1)) = checkResult('_=_[C1, C2], true) . 
  eq findTermCeqC('_=_[C1, C2]) = checkResult('_=_[C1, C2], true) . 
  eq findTermCeqC((TE1, TL1)) = findTermCeqC(TL1) .
  eq findTermCeqC(TE1) = checkResult('false.Bool, false) [owise] .
  
  eq findTermTeqC(empty) = checkResult('false.Bool, false) .
  eq findTermTeqC(('_=_[TE1, C2], TL1)) = checkResult('_=_[TE1, C2], true) .
  eq findTermTeqC(('_=_[C1, TE2], TL1)) = checkResult('_=_[C1, TE2], true) .
  eq findTermTeqC('_=_[TE1, C2]) = checkResult('_=_[TE1, C2], true) .
  eq findTermTeqC('_=_[C1, TE2]) = checkResult('_=_[C1, TE2], true) .
  eq findTermTeqC((TE1, TL1)) = findTermTeqC(TL1) .
  eq findTermTeqC(TE1) = checkResult('false.Bool, false) [owise] .

  ceq chooseTermCS(TL1) =
    (if getCheckResultBool(CR:CheckResult) then
      getCheckResultTerm(CR:CheckResult)
    else
      if getCheckResultBool(CR2:CheckResult) then
        getCheckResultTerm(CR2:CheckResult)
      else
        chooseTermCS#Notes(TL1)
      fi
    fi)
    if CR:CheckResult := findTermCeqC(TL1) /\
      CR2:CheckResult := findTermTeqC(TL1) .

  op chooseTermCS#Notes : TermList -> Term .
  op doChooseTermCS#Notes : TermList Nat Term -> Term .
  eq chooseTermCS#Notes(TE1) = TE1 . 
  ceq chooseTermCS#Notes((TE1 , TL1)) = 
      doChooseTermCS#Notes(TL1, countNodes(TE1), TE1) 
    if TL1 =/= empty .
  eq doChooseTermCS#Notes(empty, N, TE1) = TE1 .
  ceq doChooseTermCS#Notes((TE1 , TL1), N, TE2) = 
      if N2 < N then
        doChooseTermCS#Notes(TL1, N2, TE1) 
      else
        doChooseTermCS#Notes(TL1, N, TE2) 
      fi
    if N2 := countNodes(TE1) .  

endfm

--- reduce in TERM-UTILS : getCheckResultBool(findTermCeqC(('_=_['true.Bool,'_<_['place['s.Sys,'p.Pid],'s['next['s.Sys]]]],'_=_[
    --- 'true.Bool,'_<_['place['s.Sys,'p.Pid],'s['s['next['s.Sys]]]]]))) .
***(
  handle specification module (protocol specification)
)
fmod SPEC-MODULE-ANALYZE is
  pr LIST-UTILS .

  --- find transition based on Sys ** -> Sys [ctor] .
  ops getTransOpS : Qid OpDeclSet -> OpDeclSet .
  ops getTransOp : Qid OpDecl -> OpDecl .

  vars OPS : OpDeclSet .
  vars OP : OpDecl .
  vars Q1 Q2 : Qid .
  vars TL1 TL2 : TypeList .
  vars T1 T2 : Type .
  vars ATTS1 ATTS2 : AttrSet .
  
  eq getTransOpS(Q1, none) = none .
  eq getTransOpS(Q1, OP OPS) = (getTransOp(Q1, OP) getTransOpS(Q1, OPS)) .
  eq getTransOp(Q1, op Q2 : TL1 Q1 TL2 -> Q1 [ATTS1 ctor ATTS2] . ) 
    = (op Q2 : TL1 Q1 TL2 -> Q1 [ATTS1 ctor ATTS2] . ) .
  eq getTransOp(Q1, OP) = none [owise] .

  op getInitOps : Qid OpDeclSet -> OpDeclSet .
  eq getInitOps(Q1, none) = none .
  eq getInitOps(Q1, op Q2 : nil -> Q1 [ATTS1 ctor ATTS2] . OPS) =
    (op Q2 : nil -> Q1 [ATTS1 ctor ATTS2] .)
    getInitOps(Q1, OPS) .
  eq getInitOps(Q1, OP OPS) = getInitOps(Q1, OPS) [owise] .

endfm

***(
  define file input syntax
)
fmod INPUT-IPSG-SYNTAX is 
  pr QID-LIST .
  sorts Token Bubble NeTokenList .

  op token : Qid -> Token [special (id-hook Bubble (1 1) 
                                    op-hook qidSymbol (<Qids> : ~> Qid)
                                    id-hook Exclude (. { } ( )))] .

  op bubble : QidList -> Bubble [special (
          id-hook Bubble (1 -1)
          op-hook qidListSymbol (__ : QidList QidList ~> QidList) 
          op-hook qidSymbol (<Qids> : ~> Qid)
  )] .

  op neTokenList : QidList -> NeTokenList [special (
          id-hook Bubble (1 -1)
          op-hook qidListSymbol (__ : QidList QidList ~> QidList)
          op-hook qidSymbol (<Qids> : ~> Qid)
          id-hook Exclude ( . { } ( ) -> ))] .

  sorts Decl DeclList InputModule .
  subsort Decl < DeclList .

  op __ : DeclList DeclList -> DeclList [assoc gather(e E)] .
  op generate_`(_`)induction on_. : Token NeTokenList Token -> Decl .
  op generate_`(_`)induction on_only_. : Token NeTokenList Token Token -> Decl .
  op generate_`(_`). : Token NeTokenList -> Decl .
  op inv_`(_`) . : Token NeTokenList -> Decl .
  op ipsgopen_._close : Token DeclList -> InputModule .

endfm

***(
  parse file input
)
fmod INPUT-IPSG-PARSE is
  pr META-LEVEL .
  pr IPSG-INPUT-SPEC .

  vars T1 T2 T3 T4 T5 : Term .
  vars QI1 QI2 QI3 : Qid .
  vars TL TL1 TL2 TL3 : TermList .
  vars STR1 STR2 : String .

  op parseInputSpec : Term ~> IPSGInputSpec .
  eq parseInputSpec('ipsgopen_._close['token[T1], T2]) =
    inputSpec(downTerm(T1,'error),
        parseInvs(T2),
        parseInvsTarget(T2)) .

  op parseInvs : Term ~> InvList .
  op parseInvsTarget : Term ~> InvTargetList .
  op parseInvParams : Term ~> ParamList .
  op parseInvParams2 : TermList ~> ParamList .

  eq parseInvs('inv_`(_`).['token[T1], 'neTokenList['__[TL]]]) = 
    invariant(downTerm(T1, 'error), parseInvParams2(TL)) .
  
--- only one param
  eq parseInvs('inv_`(_`).['token[T1], 'neTokenList[T2]]) = 
    invariant(downTerm(T1, 'error), parseParam(downTerm(T2, 'error))) .

  eq parseInvs('__['inv_`(_`).['token[T1], 'neTokenList['__[TL]]], T3]) = 
    invariant(downTerm(T1, 'error), parseInvParams2(TL)) 
    parseInvs(T3) .
  
--- only one param
  eq parseInvs('__['inv_`(_`).['token[T1], 'neTokenList[T2]], T3]) = 
    invariant(downTerm(T1, 'error), parseParam(downTerm(T2, 'error))) 
    parseInvs(T3) .

  ceq parseInvs('__[QI1[TL], T1]) = parseInvs(T1) 
    if QI1 =/= 'inv_`(_`). .
  ceq parseInvs(QI1[TL]) = (nil).InvList
    if QI1 =/= '__ /\ QI1 =/= 'inv_`(_`). .

  eq parseInvsTarget('generate_`(_`)induction`on_only_.
    ['token[T1], 'neTokenList['__[TL]], 'token[T2], 'token[T3]]) = 
    invariantTarget2(invariant(downTerm(T1, 'error), parseInvParams2(TL)), 
      parseParam(downTerm(T2, 'error)), downTerm(T3, 'error)) .

  eq parseInvsTarget('generate_`(_`)induction`on_.
    ['token[T1], 'neTokenList['__[TL]], 'token[T2]]) = 
    invariantTarget(invariant(downTerm(T1, 'error), parseInvParams2(TL)), 
      parseParam(downTerm(T2, 'error))) .
  eq parseInvsTarget('generate_`(_`).
    ['token[T1], 'neTokenList['__[TL]]]) = 
    invariantTarget(invariant(downTerm(T1, 'error), parseInvParams2(TL)), 
      pnull) .
  
--- only one param
  eq parseInvsTarget('generate_`(_`)induction`on_only_.
    ['token[T1], 'neTokenList[T3], 'token[T2], 'token[T4]]) = 
    invariantTarget2(invariant(downTerm(T1, 'error), 
        parseParam(downTerm(T3, 'error))), 
      parseParam(downTerm(T2, 'error)), downTerm(T4, 'error)) .
      
  eq parseInvsTarget('generate_`(_`)induction`on_.
    ['token[T1], 'neTokenList[T3], 'token[T2]]) = 
    invariantTarget(invariant(downTerm(T1, 'error), 
        parseParam(downTerm(T3, 'error))), 
      parseParam(downTerm(T2, 'error))) .
  eq parseInvsTarget('generate_`(_`).
    ['token[T1], 'neTokenList[T3]]) = 
    invariantTarget(invariant(downTerm(T1, 'error), 
        parseParam(downTerm(T3, 'error))), 
      pnull) .

  eq parseInvsTarget('__['generate_`(_`)induction`on_only_.
    ['token[T1], 'neTokenList['__[TL]], 'token[T2], 'token[T4]], T3]) = 
    invariantTarget2(invariant(downTerm(T1, 'error), parseInvParams2(TL)),
      parseParam(downTerm(T2, 'error)), downTerm(T4, 'error))
    parseInvsTarget(T3) .

  eq parseInvsTarget('__['generate_`(_`)induction`on_.
    ['token[T1], 'neTokenList['__[TL]], 'token[T2]], T3]) = 
    invariantTarget(invariant(downTerm(T1, 'error), parseInvParams2(TL)),
      parseParam(downTerm(T2, 'error)))
    parseInvsTarget(T3) .
  eq parseInvsTarget('__['generate_`(_`).
    ['token[T1], 'neTokenList['__[TL]]], T3]) = 
    invariantTarget(invariant(downTerm(T1, 'error), parseInvParams2(TL)),
      pnull)
    parseInvsTarget(T3) .

--- only one param
  eq parseInvsTarget('__['generate_`(_`)induction`on_only_.
    ['token[T1], 'neTokenList[T4], 'token[T2], 'token[T5]], T3]) = 
    invariantTarget2(invariant(downTerm(T1, 'error), 
        parseParam(downTerm(T4, 'error))),
      parseParam(downTerm(T2, 'error)), downTerm(T5, 'error))
    parseInvsTarget(T3) .

  eq parseInvsTarget('__['generate_`(_`)induction`on_.
    ['token[T1], 'neTokenList[T4], 'token[T2]], T3]) = 
    invariantTarget(invariant(downTerm(T1, 'error), 
        parseParam(downTerm(T4, 'error))),
      parseParam(downTerm(T2, 'error)))
    parseInvsTarget(T3) .
  eq parseInvsTarget('__['generate_`(_`).
    ['token[T1], 'neTokenList[T4]], T3]) = 
    invariantTarget(invariant(downTerm(T1, 'error), 
        parseParam(downTerm(T4, 'error))),
      pnull)
    parseInvsTarget(T3) .

  ceq parseInvsTarget('__[QI1[TL], T1]) = parseInvsTarget(T1) 
    if QI1 =/= 'generate_`(_`)induction`on_only_. /\
      QI1 =/= 'generate_`(_`)induction`on_. /\
      QI1 =/= 'generate_`(_`). .
  ceq parseInvsTarget(QI1[TL]) = (nil).InvTargetList
    if QI1 =/= '__ /\ 
      QI1 =/= 'generate_`(_`)induction`on_only_. /\
      QI1 =/= 'generate_`(_`)induction`on_. /\
      QI1 =/= 'generate_`(_`). .

  eq parseInvParams2(T3) = 
      parseParam(downTerm(T3, 'error)) .
  ceq parseInvParams2((T3,''`,.Qid,TL1)) = 
      parseParam(downTerm(T3, 'error)) parseInvParams2(TL1) 
    if TL1 =/= empty .

--- S:Sys -> param('S, 'Sys)
  op parseParam : Qid -> Param .
  op parseParam2 : String -> Param .
  eq parseParam(QI1) = parseParam2(string(QI1)) .
  eq parseParam2(STR1) = param(
    qid(substr(STR1, 0, find(STR1, ":", 0))),
    qid(substr(STR1, s(find(STR1, ":", 0)), sd(length(STR1), find(STR1, ":", 0))))
  ) .

endfm


***(
  releated to pre-processing condition equations
)
fmod IPSG-CONDITION-EQUATION is
  pr META-LEVEL .
  pr TERM-CHECK-RESULT . 

  vars T1 T2 T3 T4 T5 T6 T7 T8 : Term .
  vars B1 B2 : Bool .
  vars CEQ1 CEQ2 CEQ3 CEQ4 : EqCondition .
  vars TY1 TY2 : Type .
  vars TYL1 TYL2 : TypeList .
  vars TEL1 TEL2 TEL3 TEL4 : TermList .
  vars TE1 TE2 TE3 TE4 : Term .
  vars Q1 Q2 Q3 : Qid .
  vars C1 C2 C3 : Constant .
  vars V1 V2 V3 : Variable .
  var M : Module .

  op checkMatchParams : TypeList TermList -> Bool .
  eq checkMatchParams((nil).TypeList, empty) = true .
  eq checkMatchParams(TY1 TYL1, (TE1 , TEL1)) =
    if getType(TE1) == TY1 then
      checkMatchParams(TYL1, TEL1)
    else
      false 
    fi .

  op checkMatchParamsTermL : TermList TermList -> Bool .
  op checkMatchParamsTerm : Term Term -> Bool .
  eq checkMatchParamsTerm(C1, C2) = (C1 == C2) .
  eq checkMatchParamsTerm(V1, V2) = (getType(V1) == getType(V2)) .
  eq checkMatchParamsTerm(Q1[TEL1], Q1[TEL2]) = 
    checkMatchParamsTermL(TEL1, TEL2) .
  eq checkMatchParamsTerm(TE1, TE2) = false [owise] .

  eq checkMatchParamsTermL(empty, empty) = true .
  eq checkMatchParamsTermL((TE1 , TEL1) , (TE2 , TEL2)) = 
    if checkMatchParamsTerm(TE1, TE2) then
      checkMatchParamsTermL(TEL1, TEL2)
    else
      false 
    fi .

  op checkContrast1 : EqCondition EqCondition Module -> CheckResult .
  op checkContrast2 : Term Term -> CheckResult .
  ceq checkContrast1(TE1 = 'true.Bool, TE2 = 'true.Bool,M) 
    = checkContrast2(TE3, TE4) 
  if TE3 := getTerm(metaReduce(M, TE1)) /\
     TE4 := getTerm(metaReduce(M, TE2)) .
  eq checkContrast1(CEQ1, CEQ2, M) = checkResult('false.Bool, false) [owise] .

  eq checkContrast2(
      Q1[TEL1],
      '_xor_['true.Bool, Q1[TEL2]]
    ) = 
    if checkMatchParamsTermL(TEL1, TEL2) then
      checkResult(Q1[TEL1], true) 
    else
      checkResult('false.Bool, false) 
    fi .
  eq checkContrast2(
      '_xor_['true.Bool, Q1[TEL1]],
      Q1[TEL2]
    ) = 
    if checkMatchParamsTermL(TEL1, TEL2) then
      checkResult('_=_['false.Bool, Q1[TEL1]], true) 
    else
      checkResult('false.Bool, false) 
    fi .

  eq checkContrast2(
      Q1[TEL1],
      '_=_['false.Bool, Q1[TEL2]]
    ) = 
    if checkMatchParamsTermL(TEL1, TEL2) then
      checkResult(Q1[TEL1], true) 
    else
      checkResult('false.Bool, false) 
    fi .
  eq checkContrast2(
      '_=_['false.Bool, Q1[TEL1]],
      Q1[TEL2]
    ) = 
    if checkMatchParamsTermL(TEL1, TEL2) then
      checkResult('_=_['false.Bool, Q1[TEL1]], true) 
    else
      checkResult('false.Bool, false) 
    fi .
  
  eq checkContrast2(
      '_xor_[Q1[TEL1], Q2[TEL2]],
      '_xor_['true.Bool, Q1[TEL3], Q2[TEL4]]
    ) = 
    if checkMatchParamsTermL(TEL1, TEL3) and checkMatchParamsTermL(TEL2, TEL4) then
      checkResult('_xor_[Q1[TEL1], Q2[TEL2]], true) 
    else
      checkResult('false.Bool, false) 
    fi .
  eq checkContrast2(
      '_xor_['true.Bool, Q1[TEL1], Q2[TEL2]],
      '_xor_[Q1[TEL3], Q2[TEL4]]
    ) = 
    if checkMatchParamsTermL(TEL1, TEL3) and checkMatchParamsTermL(TEL2, TEL4) then
      checkResult('_=_['false.Bool, '_xor_[Q1[TEL1], Q2[TEL2]]], true) 
    else
      checkResult('false.Bool, false) 
    fi .
  eq checkContrast2(
      '_xor_[Q1[TEL1], Q2[TEL2]],
      '_xor_['true.Bool, Q2[TEL4], Q1[TEL3]]
    ) = 
    if checkMatchParamsTermL(TEL1, TEL3) and checkMatchParamsTermL(TEL2, TEL4) then
      checkResult('_xor_[Q1[TEL1], Q2[TEL2]], true) 
    else
      checkResult('false.Bool, false) 
    fi .
  eq checkContrast2(
      '_xor_['true.Bool, Q1[TEL1], Q2[TEL2]],
      '_xor_[Q2[TEL4], Q1[TEL3]]
    ) = 
    if checkMatchParamsTermL(TEL1, TEL3) and checkMatchParamsTermL(TEL2, TEL4) then
      checkResult('_=_['false.Bool, '_xor_[Q1[TEL1], Q2[TEL2]]], true) 
    else
      checkResult('false.Bool, false) 
    fi .
  eq checkContrast2(
      '_xor_['true.Bool, TE1, TE2, TE3],
      '_xor_[TE1, TE2, TE3]
    ) = checkResult('_=_['false.Bool, '_xor_[TE1, TE2, TE3]], true) .
  eq checkContrast2(
      '_xor_[TE1, TE2, TE3],
      '_xor_['true.Bool, TE1, TE2, TE3]
    ) = checkResult('_xor_[TE1, TE2, TE3], true) .

  eq checkContrast2(TE1, TE2) = checkResult('false.Bool, false) [owise] .

  --- TODO: add more implementation here
endfm

***(
  mostly rewrite a list of ceq(s) to eq, e.g., 
  ceq pc(want(S,P),Q) = (if P = Q then l1 else pc(S,Q) fi) if (pc(S,P) = rs) ., and
  ceq want(S,P) = S if ((pc(S,P) = rs) = false) ., should be rewriten to 
  eq pc(want(S,P),Q) = 
    if (pc(S,P) = rs) then
      (if P = Q then l1 else pc(S,Q) fi)
    else
      pc(S,Q) 
    fi .
)
fmod IPSG-PRE-PROCESSING is
  pr IPSG-CONDITION-EQUATION .

  vars T1 T2 T3 T4 T5 T6 : Term .
  vars B1 B2 : Bool .
  vars EQS1 EQS2 : EquationSet .
  vars EQ1 EQ2 : Equation .
  vars CON1 CON2 CON3 : EqCondition .
  vars ATTR1 ATTR2 : AttrSet .
  vars OP1 OP2 : OpDecl .
  vars Q1 Q2 : Qid .
  vars TYL1 TYL2 : TypeList .
  vars TY1 TY2 : Type .
  vars TEL1 TEL2 TEL3 TEL4 : TermList .
  vars TE1 TE2 TE3 : Term .
  vars MOD1 MOD2 : Module .
  vars OPS1 OPS2 : OpDeclSet .

---  find ceq chglk(S,P) = S if ((pc(S,P) = l8) = false) .
  op findTranCondEqs : EquationSet OpDecl -> EquationSet .
  eq findTranCondEqs(none, OP1) = none .
  eq findTranCondEqs(
      ceq Q1[TEL1] = T2 if CON1 [ATTR1] . EQS1,
      op Q1 : TYL1 -> Q2 [ATTR2] .
    ) = 
    if checkMatchParams(TYL1, TEL1) then 
      ceq Q1[TEL1] = T2 if CON1 [ATTR1] .
    else 
      none
    fi 
    findTranCondEqs(EQS1, op Q1 : TYL1 -> Q2 [ATTR2] .) .
  eq findTranCondEqs(EQS1, OP1) = none [owise] .

  op findTranCondEq : EquationSet -> Equation .
  eq findTranCondEq(EQ1 EQS1) = EQ1 .

--- find ceq pc(chglk(S,P),Q) ... if (pc(S,P) = l8) .
  op replaceCondEqs : EquationSet OpDecl Equation Module -> EquationSet .
  eq replaceCondEqs(none, OP1, EQ1, MOD1) = none .
  ceq replaceCondEqs(
      ceq Q1[TEL1 , Q2[TEL2] , TEL3] = T2 if CON1 [ATTR1] . EQS1,
      OP1,
      ceq Q2[TEL4] = T3 if CON2 [ATTR2] .,
      MOD1
    ) = 
    if checkMatchParamsTermL(TEL2, TEL4) and
        getCheckResultBool(CR:CheckResult) then
      eq Q1[TEL1 , Q2[TEL2] , TEL3] = 
        'if_then_else_fi[getCheckResultTerm(CR:CheckResult),
          T2,
          Q1[TEL1 , T3 , TEL3] ]
        [ATTR1] .
    else
      ceq Q1[TEL1 , Q2[TEL2] , TEL3] = T2 if CON1 [ATTR1] .
    fi 
    replaceCondEqs(EQS1, OP1, ceq Q2[TEL2] = T3 if CON2 [ATTR2] ., MOD1) 
    if CR:CheckResult := checkContrast1(CON1, CON2, MOD1) .
  
  eq replaceCondEqs(EQ1 EQS1, OP1, EQ2, MOD1) 
    = EQ1 replaceCondEqs(EQS1, OP1, EQ2, MOD1) [owise] .

  op replaceAllCondEqs : Module OpDeclSet -> Module .
  eq replaceAllCondEqs(MOD1, none) = MOD1 . 
  eq replaceAllCondEqs(MOD1, OP1 OPS1) = 
   replaceAllCondEqs(
    fmod getName(MOD1) is 
          getImports(MOD1)
          sorts getSorts(MOD1) .
          getSubsorts(MOD1)
          getOps(MOD1)
          getMbs(MOD1)
          replaceCondEqs(getEqs(MOD1), OP1, 
            findTranCondEq(findTranCondEqs(getEqs(MOD1), OP1)),
            MOD1)
      endfm,
    OPS1
  ) .

endfm

***(
  when false is returned for a proof score fragment,
  we will try to test if we can use any lemmas
)
fmod ISPG-HANDLE-INVS is
  pr IPSG-PROOF-SCORE-LIST .
  pr IPSG-INPUT-SPEC .
  pr PARAM-PERMUTATION-SET .
  pr TERM-PERMUTATION-SET .
  pr TO-QID-LIST .
  pr ISPG-LEMMA-CONJECTURE .
  pr IPSG-CONFIG .
  pr TERM-CHECK-RESULT-LIST .
  pr PARSE-TERM .
  pr HANDLE-EQS-CS .
  pr INV-TERMPERMUTATIONSET-MAP .

  op permutateParams : ParamList ParamList -> ParamPernSet .
  op doPermutateParams : ParamList ParamList ParamList -> ParamPernSet .
  op doPermutateParams2 : ParamList ParamList ParamList ParamList -> ParamPernSet .
  op findMatches : Param ParamList -> ParamList .
  op doFindMatches : Param ParamList ParamList -> ParamList .
  op remove : ParamList Param -> ParamList .
  op doRemove : ParamList Param ParamList -> ParamList .
  
  vars QIL QIL1 QIL2 : QidList .
  vars QI QI1 QI2 QI3 QI4 : Qid .
  vars INSP2 INSP1 : IPSGInputSpec .
  vars PRL1 PRL2 PRL3 PRL4 : ParamList .
  vars PA1 PA2 : Param .
  vars PRSC1 PRSC2 PRSC3 PRSC4 : IPSGProofScore .
  vars PRSCL1 PRSCL2 : PrscList .
  vars MS1 MS2 : IPSGModuleSpec .
  vars INV1 INV2 : Invariant .
  vars INVL INVL2 : InvList .
  var N : Nat .
  var PP : ParamPernSet .
  vars TP TP0 : TermPernSet .
  vars MOD MOD1 MOD2 : Module .
  var EQS : EquationSet .
  vars EQ1 EQ2 : Equation .
  vars ATTS : AttrSet .
  vars TE1 TE2 TE3 : Term .
  vars TEL TEL2 : TermList .

  vars C1 C2 C3 C4 : Constant .
  vars OPS1 OPS2 : OpDeclSet .
  vars OP1 OP2 : OpDecl .
  vars ATTS1 : AttrSet .
  vars MAP1 MAP2 : MapNatEquation .
  vars TCL : TupleConstList .
  --- vars CL : ConstList .
  vars CL : TermList .
  vars MCV1 MCV2 : MapConstVar .
  vars V1 V2 : Variable .
  var LM : LemmaGenerated .
  vars STR1 STR2 : String .
  vars CRL : CheckResultList .
  vars CR CR1 CR2 : CheckResult .
  vars MITPS : MapInvTermPernSet .

  eq remove(PRL1, PA1) = doRemove(PRL1, PA1, (nil).ParamList) .
  eq doRemove((nil).ParamList, PA2, PRL2) = PRL2 .
  eq doRemove(PA1 PRL1, PA1, PRL2) = PRL2 PRL1 .
  ceq doRemove(PA1 PRL1, PA2, PRL2) = doRemove(PRL1, PA2, PRL2 PA1) 
    if PA1 =/= PA2 .

  eq findMatches(PA1, PRL2) = doFindMatches(PA1, PRL2, (nil).ParamList) .
  eq doFindMatches(PA1, (nil).ParamList, PRL1) = PRL1 .
  eq doFindMatches(PA1, PA2 PRL2, PRL3) =
    if getParamType(PA1) == getParamType(PA2) then
      doFindMatches(PA1, PRL2, PRL3 PA2)
    else
      doFindMatches(PA1, PRL2, PRL3)
    fi .
  
***(
    PRL1 is an invariant that we want to test if can be used as a lemma
    PRL2 is the current inv, which need to generate its proof scores
)
  eq permutateParams(PRL1, PRL2) = doPermutateParams(PRL1, PRL2, (nil).ParamList) .
  eq doPermutateParams((nil).ParamList, PRL2, PRL3) = {PRL3} .
  ceq doPermutateParams(PA1 PRL1, PRL2, PRL3) =
    (if size(MATCHES:ParamList) == 0 then
      empty
    else
      if size(MATCHES:ParamList) == 1 then
        doPermutateParams(PRL1, remove(PRL2, head(MATCHES:ParamList)), 
          PRL3 MATCHES:ParamList)
      else
        doPermutateParams2(PRL1, PRL2, PRL3, MATCHES:ParamList)
      fi
    fi)
    if MATCHES:ParamList := findMatches(PA1, PRL2) .

  eq doPermutateParams2(PRL1, PRL2, PRL3, PA1 (nil).ParamList) =
    doPermutateParams(PRL1, remove(PRL2, PA1), PRL3 PA1) .
  ceq doPermutateParams2(PRL1, PRL2, PRL3, PA1 PRL4) =
    doPermutateParams(PRL1, remove(PRL2, PA1), PRL3 PA1) ,
    doPermutateParams2(PRL1, PRL2, PRL3, PRL4)
    if PRL4 =/= (nil).ParamList .

  op handleFalseCase : IPSGProofScore IPSGModuleSpec IPSGInputSpec -> PrscList .
  ceq handleFalseCase(PRSC1, MS1, INSP1) = 
    if PRSC2 == PRSC1 then
      if testUseInvsT(PRSC1, MS1, INVL) == PRSC1 then
        if tryUseMt1Lm(PRSC1, MS1, INVL, INVL, 
            genMapInvTermPernSet(INVL, MOD, getEqs(getPrscModule(PRSC1))), 
            (none).EquationSet, depthTryUseLm) == PRSC1 then
          if autoGenLemmas then
            conjectLemma(PRSC1, MS1, INSP1)
          else
            addComment2Prsc(PRSC1, '\r 'false '\o)
          fi
        else
          tryUseMt1Lm(PRSC1, MS1, INVL, INVL, 
            genMapInvTermPernSet(INVL, MOD, getEqs(getPrscModule(PRSC1))), 
            (none).EquationSet, depthTryUseLm)
        fi
      else
        testUseInvsT(PRSC1, MS1, INVL)
      fi
    else
      PRSC2
    fi
    if INVL := getInputSpecInvs(INSP1) /\
    PRSC2 := testUseInvs(PRSC1, MS1, INVL) /\
    MOD := tempMod2(getPrscModule(PRSC1), MS1, getPrscILemma(PRSC1)) .

  op testUseInvs : IPSGProofScore IPSGModuleSpec InvList -> IPSGProofScore .
  op testUseInv : IPSGProofScore IPSGModuleSpec Invariant -> IPSGProofScore .
  op doTestUseInv : IPSGProofScore IPSGModuleSpec Invariant ParamPernSet -> IPSGProofScore .
  
  eq testUseInvs(PRSC1, MS1, (nil).InvList) = PRSC1 .
  ceq testUseInvs(PRSC1, MS1, INV1 INVL) =
    if PRSC2 == PRSC1 then
      testUseInvs(PRSC1, MS1, INVL)
    else
      PRSC2
    fi
    if PRSC2 := testUseInv(PRSC1, MS1, INV1) .
  
  ceq testUseInv(PRSC1, MS1, INV1) =
    if P:ParamPernSet == empty then
      PRSC1
    else
      doTestUseInv(PRSC1, MS1, INV1, P:ParamPernSet)
    fi
    if P:ParamPernSet :=
      permutateParams(getInvParams(INV1),
        getInvTargetParams(PRSC1) getInvTransParams(PRSC1)) .

  eq doTestUseInv(PRSC1, MS1, INV1, empty) = PRSC1 .
  ceq doTestUseInv(PRSC1, MS1, INV1, ({PRL1}, PP)) =
    (if RE:Term == 'true.Bool then
      prsc(getPrscModule(PRSC1),
        (getInvName(INV1) '`( genEqParams(PRL1) '`) ) ' 'implies 
          getPrscReductionCmd(PRSC1),
        TE:Term,
        '\g 'true '`, ' 'use getInvName(INV1) 'as 'a 'lemma '\o,
        getPrscMapEqs(PRSC1),
        getInvTagetName(PRSC1),
        getInvTargetParams(PRSC1),
        getInvTransName(PRSC1),
        getInvTransParams(PRSC1),
        getPrscILemma(PRSC1))
    else
      doTestUseInv(PRSC1, MS1, INV1, PP)
    fi)
    if MOD := tempMod2(getPrscModule(PRSC1), MS1, getPrscILemma(PRSC1)) /\ 
      TE:Term := '_implies_[
        getInvName(INV1)[ genEqParamsTerm(MOD, PRL1) ], 
        getPrscMetaReduceCmd(PRSC1)] /\
      RE:Term := getTerm(metaReduce(MOD, TE:Term)) .

***(
  try to use an invariant as a lemma by replace the params of lemma with
  any wellFormed terms.
  e.g., inv8(s, s(next(s)), s(s(next(s)))) implies inv7....
)
  op testUseInvsT : IPSGProofScore IPSGModuleSpec InvList -> IPSGProofScore .
  op testUseInvT : IPSGProofScore IPSGModuleSpec Invariant -> IPSGProofScore .
  op doTestUseInvT : IPSGProofScore Module Invariant TermPernSet -> IPSGProofScore .
  --- op tryReplaceParam : IPSGProofScore Module Invariant MapParamTL 
    --- ParamList MapParamTL -> IPSGProofScore .
  op findMatchesT : Module EquationSet Param -> TermList .
  op doFindMatchesT : Module Term Param -> TermList .
  op doFindMatchesT2 : Module TermList Param -> TermList .
  op findMatchesTL : Module EquationSet ParamList -> TermPernSet .
  op doFindMatchesTL : Module EquationSet ParamList TermList -> TermPernSet .
  op doFindMatchesTL2 : TermList Module EquationSet ParamList TermList 
    -> TermPernSet .

  eq findMatchesTL(MOD, (none).EquationSet, PRL1) = (empty).TermPernSet .
  eq findMatchesTL(MOD, EQS, PRL1) = doFindMatchesTL(MOD, EQS, PRL1, empty) [owise] .
  eq doFindMatchesTL(MOD, EQS, (nil).ParamList, TEL) = {TEL} .

  ceq doFindMatchesTL(MOD, EQS, PA1 PRL1, TEL) = 
    if MATCHES:TermList == empty then
      empty
    else 
      if MATCHES:TermList :: Term then
        doFindMatchesTL(MOD, EQS, PRL1, (TEL, MATCHES:TermList))
      else
        doFindMatchesTL2(MATCHES:TermList, MOD, EQS, PRL1, TEL)
      fi
    fi
    if MATCHES:TermList := findMatchesT(MOD, EQS, PA1) .
  
  eq doFindMatchesTL2((TE1, empty), MOD, EQS, PRL1, TEL2) =
    doFindMatchesTL(MOD, EQS, PRL1, (TEL2, TE1)) .
  ceq doFindMatchesTL2((TE1, TEL), MOD, EQS, PRL1, TEL2) =
    doFindMatchesTL(MOD, EQS, PRL1, (TEL2, TE1)),
    doFindMatchesTL2(TEL, MOD, EQS, PRL1, TEL2)
    if TEL =/= empty .

  eq findMatchesT(MOD, none, PA1) = empty .
  eq findMatchesT(MOD, (eq TE1 = TE2 [ ATTS ] .) EQS, PA1) =
    appendList(appendList(doFindMatchesT(MOD, TE1, PA1),
      doFindMatchesT(MOD, TE2, PA1)),
      findMatchesT(MOD, EQS, PA1)) .

  ceq doFindMatchesT(MOD, QI[TEL], param(QI1, QI2)) =
    if B:Bool then
      appendList(getTerm(metaReduce(MOD,QI[TEL])), 
        doFindMatchesT2(MOD, TEL, param(QI1, QI2)))
    else
      doFindMatchesT2(MOD, TEL, param(QI1, QI2))
    fi 
    if B:Bool := wellFormed(MOD, qid("VAR:" + string(QI2)) <- QI[TEL]) .

  eq doFindMatchesT(MOD, TE1, param(QI1, QI2)) =
    if wellFormed(MOD, qid("VAR:" + string(QI2)) <- TE1) then
      TE1
    else
      empty
    fi .

  eq doFindMatchesT2(MOD, empty, PA1) = empty .
  eq doFindMatchesT2(MOD, (TE1, TEL), PA1) = 
    appendList(doFindMatchesT(MOD, TE1, PA1),
      doFindMatchesT2(MOD, TEL, PA1)) .

  eq testUseInvsT(PRSC1, MS1, (nil).InvList) = PRSC1 .
  ceq testUseInvsT(PRSC1, MS1, INV1 INVL) = 
    if PRSC2 == PRSC1 then
      testUseInvsT(PRSC1, MS1, INVL)
    else
      PRSC2
    fi 
    if PRSC2 := testUseInvT(PRSC1, MS1, INV1) .

  ceq testUseInvT(PRSC1, MS1, INV1) = 
    if TP == empty then
      PRSC1
    else
      doTestUseInvT(PRSC1, MOD, INV1, TP)
    fi
    if MOD := tempMod2(getPrscModule(PRSC1), MS1, getPrscILemma(PRSC1)) /\
      TP := findMatchesTL(
        MOD, getEqs(getPrscModule(PRSC1)), getInvParams(INV1)) .

  eq doTestUseInvT(PRSC1, MOD, INV1, (empty).TermPernSet) = PRSC1 .
  ceq doTestUseInvT(PRSC1, MOD, INV1, ({TEL}, TP)) =
    (if RE:Term == 'true.Bool then
      prsc(getPrscModule(PRSC1),
        (getInvName(INV1) '`( myDownTermL(TEL, MOD) '`) ) ' 'implies 
          getPrscReductionCmd(PRSC1),
        TE:Term,
        '\g 'true '`, ' 'use getInvName(INV1) 'as 'a 'lemma '\o,
        getPrscMapEqs(PRSC1),
        getInvTagetName(PRSC1),
        getInvTargetParams(PRSC1),
        getInvTransName(PRSC1),
        getInvTransParams(PRSC1),
        getPrscILemma(PRSC1))
    else
      doTestUseInvT(PRSC1, MOD, INV1, TP)
    fi)
    if TE:Term := '_implies_[
        getInvName(INV1)[ TEL ],
        getPrscMetaReduceCmd(PRSC1)] /\
      RE:Term := getTerm(metaReduce(MOD, TE:Term)) .


  op conjectLemma : IPSGProofScore IPSGModuleSpec IPSGInputSpec -> IPSGProofScore .
  ceq conjectLemma(PRSC1, MS1, INSP1) = 
    addComment2Prsc(
      handleFalseCase(
        addLemmas2Prsc(PRSC1,LM),
        MS1,
        addLmsInv(INSP1,lm2InvInput(LM))
      ), 
      '\m 'generated 'and 'used 'as 'a 'lemma '\o '\n
      '-- tokenize(STR1) '\n 
      '-- aEq2QidListRaw(EQ1,getPrscModule(PRSC1)))
  if
    N := s(getIPSGLmsNo(getPrscILemma(PRSC1))) /\
    QI1 := handleLmName(getInvTagetName(PRSC1),N) /\
    TEL := getFreshConstList(PRSC1) /\
    TCL := getEqConstPairs(PRSC1) /\
    MCV1 := generateMapConstVar(TEL,TCL) /\
    OP1 := generateLmOpDel(QI1, MCV1) /\
    MOD := tempMod2(getPrscModule(PRSC1), MS1, getPrscILemma(PRSC1)) /\
    EQ1 := generateLmEquation(QI1, 
      reduceEqsSet(getEqs(getPrscModule(PRSC1)), MOD), MCV1, TCL) /\
    LM := lm(OP1, EQ1, N) /\
    STR1 := aOp2String(OP1) /\
    STR2 := aEq2String(EQ1, getPrscModule(PRSC1)) .

  op handleLmName : Qid Nat -> Qid .
  ceq handleLmName(QI1,N) =
    (if substr(STR1:String,0,2) == "lm" then
      qid(STR1:String + "-" + string(N,10))
    else
      qid(prefixLmName + string(N,10))
    fi)
    if STR1:String := string(QI1) .

***(
  try to use more than one invariants as lemmas
)
  op tryUseMt1Lm : IPSGProofScore IPSGModuleSpec InvList 
    InvList MapInvTermPernSet EquationSet Nat -> PrscList .
  --- eq tryUseMt1Lm(PRSC1, MS1, INVL, (nil).InvList, MITPS, EQS, N) = PRSC1 .
  ceq tryUseMt1Lm(PRSC1, MS1, INVL, INVL2, MITPS, EQS, N) = PRSC1 
    if N == 0 or INVL2 == (nil).InvList .
  ceq tryUseMt1Lm(PRSC1, MS1, INVL, INV1 INVL2, MITPS, EQS, N) = 
    (if PRSCL2 == PRSC1 then
      tryUseMt1Lm(PRSC1, MS1, INVL, INVL2, MITPS, EQS, N)
    else
      PRSCL2
    fi) 
    if PRSCL2 := tryUseMt1Lm'(PRSC1, MS1, INVL, INV1, MITPS, EQS, N) [owise] .

  op tryUseMt1Lm' : IPSGProofScore IPSGModuleSpec InvList 
    Invariant MapInvTermPernSet EquationSet Nat -> PrscList .
  ceq tryUseMt1Lm'(PRSC1, MS1, INVL, INV1, MITPS, EQS, N) = 
    if PRSCL2 == PRSC1 then
      doTryUseMt1Lm'(PRSC1, MOD, INV1, TP, MS1, INVL, MITPS, EQS, N)
    else
      PRSCL2
    fi
    if MOD := tempMod2(getPrscModule(PRSC1), MS1, getPrscILemma(PRSC1)) /\
      TP0 := findMatchesTL(MOD, EQS, getInvParams(INV1)) /\
      TP := MITPS[INV1] /\
      PRSCL2 := doTryUseMt1Lm'(PRSC1, MOD, INV1, TP0, MS1, INVL, MITPS, EQS, N) /\
      QI := getInvName(INV1) .

  op doTryUseMt1Lm' : IPSGProofScore Module Invariant TermPernSet 
    IPSGModuleSpec InvList MapInvTermPernSet EquationSet Nat -> PrscList .
  eq doTryUseMt1Lm'(PRSC1, MOD, INV1, (empty).TermPernSet, MS1, INVL, 
    MITPS, EQS, N) = PRSC1 .
  ceq doTryUseMt1Lm'(PRSC1, MOD, INV1, ({TEL}, TP), MS1, INVL, 
    MITPS, EQS, N) =
    *** choose one term from CRL to conduct case splitting
      if PRSCL1 == PRSC1 then
        doTryUseMt1Lm'(PRSC1, MOD, INV1, TP, MS1, INVL, MITPS, EQS, N)
      else
        PRSCL1
      fi
    if TE1 := getInvName(INV1)[ TEL ] /\
       TE2 := getTerm(metaReduce(MOD, TE1)) /\
       CRL := getTermListRd2False(PRSC1, MOD, TE2, extractSplitCasesT(TE2)) /\
       PRSCL1 := doTryUseMt1Lm'2(PRSC1, MOD, INV1, CRL, TEL, MS1, INVL, MITPS, EQS, N) .

  op doTryUseMt1Lm'2 : IPSGProofScore Module Invariant CheckResultList 
    TermList IPSGModuleSpec InvList MapInvTermPernSet EquationSet Nat -> PrscList .
  eq doTryUseMt1Lm'2(PRSC1, MOD, INV1, nil, TEL, MS1, INVL, MITPS, EQS, N) = PRSC1 .
  ceq doTryUseMt1Lm'2(PRSC1, MOD, INV1, (checkResult(TE1, B:Bool) CRL), 
    TEL, MS1, INVL, MITPS, EQS, N) = 
      if PRSCL1 =/= PRSC2 or
            getTerm(metaReduce(
              tempMod2(getPrscModule(PRSC2), MS1, getPrscILemma(PRSC2)), 
              getPrscMetaReduceCmd(PRSC2))) == 'true.Bool 
          then --- the remaining prsc still returns true even do not need to use another lemma
        if B:Bool == true then 
          PRSC4 PRSCL1
        else
          PRSCL1 PRSC4
        fi
      else
        doTryUseMt1Lm'2(PRSC1, MOD, INV1, CRL, TEL, MS1, INVL, MITPS, EQS, N)
      fi
    if EQT:Equation := makeEqT(TE1, MOD, getPrscModule(PRSC1)) /\
        EQF:Equation := makeEqF(TE1, MOD, getPrscModule(PRSC1)) /\
        PRSC2 := if B:Bool == true then 
            addEquation2Prsc(PRSC1, EQF:Equation, 2)
          else
            addEquation2Prsc(PRSC1, EQT:Equation, 1)
          fi /\
        PRSC3 := if B:Bool == true then 
            addEquation2Prsc(PRSC1, EQT:Equation, 1)
          else
            addEquation2Prsc(PRSC1, EQF:Equation, 2)
          fi /\
        PRSC4 := 
          prsc(getPrscModule(PRSC3),
            (getInvName(INV1) '`( myDownTermL(TEL, getPrscModule(PRSC3)) '`) ) 
              ' 'implies getPrscReductionCmd(PRSC3),
            '_implies_[
              getInvName(INV1)[ TEL ], 
              getPrscMetaReduceCmd(PRSC3)],
            '\g 'true '`, ' 'use getInvName(INV1) 'as 'a 'lemma '\o,
            getPrscMapEqs(PRSC3),
            getInvTagetName(PRSC3),
            getInvTargetParams(PRSC3),
            getInvTransName(PRSC3),
            getInvTransParams(PRSC3),
            getPrscILemma(PRSC3)) /\
       PRSCL1 := tryUseMt1Lm2(PRSC2, MS1, INVL, MITPS, EQS EQT:Equation, N) .

  op tryUseMt1Lm2 : IPSGProofScore IPSGModuleSpec InvList 
    MapInvTermPernSet EquationSet Nat -> PrscList .
  --- this case do not need to use another lemma, 
  --- but the remaining prsc still returns true
  ceq tryUseMt1Lm2(PRSC1, MS1, INVL, MITPS, EQS, N) =
      if TE1 == 'true.Bool then
        PRSC1
      else
        tryUseMt1Lm2'(PRSC1, MS1, INVL, MITPS, EQS, N)
      fi
    if MOD := tempMod2(getPrscModule(PRSC1), MS1, getPrscILemma(PRSC1)) /\ 
      TE1 := getTerm(metaReduce(MOD, getPrscMetaReduceCmd(PRSC1))) .

  op tryUseMt1Lm2' : IPSGProofScore IPSGModuleSpec InvList 
    MapInvTermPernSet EquationSet Nat -> PrscList .
  ceq tryUseMt1Lm2'(PRSC1, MS1, INVL, MITPS, EQS, s(N)) =
      if PRSC2 == PRSC1 then
        tryUseMt1Lm(PRSC1, MS1, INVL, INVL, MITPS, EQS, N)
      else
        PRSC2
      fi
    if PRSC2 := testUseInvsT(PRSC1, MS1, INVL) .

*** get a list of terms (equation) such that when we add it,
*** the term will be reduced to false
  op getTermListRd2False : IPSGProofScore Module Term TermList -> CheckResultList .
  eq getTermListRd2False(PRSC1, MOD, TE1, (empty).TermList) = nil .
  ceq getTermListRd2False(PRSC1, MOD, TE1, (TE2 , TEL)) =
      if getTerm(metaReduce(MOD1, TE1)) == 'false.Bool then
        checkResult(TE2, true)
      else 
        if getTerm(metaReduce(MOD2, TE1)) == 'false.Bool then
          checkResult(TE2, false)
        else
          nil
        fi
      fi 
      getTermListRd2False(PRSC1, MOD, TE1, (TEL))
    if EQT:Equation := makeEqT(TE2,MOD,getPrscModule(PRSC1)) /\
       EQF:Equation := makeEqF(TE2,MOD,getPrscModule(PRSC1)) /\
       MOD1 := copyModule&AddEqs2(MOD, EQT:Equation, 1) /\
       MOD2 := copyModule&AddEqs2(MOD, EQF:Equation, 2) .

*** build a map
  op genMapInvTermPernSet : InvList Module EquationSet -> MapInvTermPernSet .
  eq genMapInvTermPernSet((nil).InvList, MOD, EQS) 
    = (empty).MapInvTermPernSet .
  eq genMapInvTermPernSet(INVL, MOD, (none).EquationSet) 
    = (empty).MapInvTermPernSet .
  eq genMapInvTermPernSet(INV1 INVL, MOD, EQS) = 
    insert(INV1, findMatchesTL(MOD, EQS, getInvParams(INV1)),
      genMapInvTermPernSet(INVL, MOD, EQS)) .

endfm

***(
  core algorithm of the tool
)
mod IPSG-HANDLE is
  pr SPEC-MODULE-ANALYZE .
  pr IPSG-CONSTANT .
  pr STRING-UTILS .
  pr IPSG-PROOF-SCORE-LIST .
  pr IPSG-INPUT-SPEC .
  pr IPSG-PRE-PROCESSING .
  pr ISPG-HANDLE-INVS .
  --- pr TERM-ANALYSIS .

  sort IPSGState .

  op IPSGState-init : -> IPSGState [ctor] .
  op <_;_;_> : IPSGInputSpec IPSGModuleSpec IPSGProofScores -> IPSGState .
  
  vars QIL QIL1 QIL2 : QidList . 
  vars QI QI1 QI2 QI3 QI4 : Qid . 
  vars INSP2 INSP1 : IPSGInputSpec .
  vars OPS1 OPS2 OPS3 : OpDeclSet .
  vars OP1 OP2 : OpDecl .
  vars TL1 TL2 : TypeList .
  vars T1 T2 : Type .
  vars PRL1 PRL2 : ParamList .
  vars PA1 PA2 : Param .
  vars ATTS1 ATTS2 : AttrSet .
  vars N1 N2 : Nat .
  vars STR1 STR2 : String .
  vars PRSC1 PRSC2 : IPSGProofScore .
  vars PRSCL1 PRSCL2 : PrscList .
  vars MS1 MS2 : IPSGModuleSpec .
  vars TE TE2 TE3 TE4 : Term .
  vars TEL TEL2 : TermList .
  vars INV1 INV2 : Invariant .
  vars INVL : InvList .
  vars INVT1 INVT2 : InvariantTarget .
  vars INVTL : InvTargetList .

  vars ILS : IPSGLemmas .
  vars LMS LMS1 : ListLemmas .
  vars LM1 LM2 : LemmaGenerated .

--- apply theorem of constant
  op applyToCIndVarParam : Param -> Param .
  eq applyToCIndVarParam(param(QI1, QI2)) = param(toLowerCaseQ(QI1), QI2) .

  op applyToCInvParams : ParamList -> ParamList .
  eq applyToCInvParams((nil).ParamList) = (nil).ParamList .
  eq applyToCInvParams(param(QI1, QI2) PRL1) 
    = param(toLowerCaseQ(QI1), QI2) applyToCInvParams(PRL1) .

  op applyToCTranParams : TypeList Param ParamList -> ParamList .
  op applyToCTranParams1 : TypeList Param Nat ParamList -> ParamList .
  eq applyToCTranParams(TL1, PA1, PRL1) = applyToCTranParams1(TL1, PA1, 1, PRL1) .
  eq applyToCTranParams1((nil).TypeList, PA1, N1, PRL1) = (nil).ParamList .
  eq applyToCTranParams1(T1 TL1, param(QI1, QI2), N1, PRL1) 
    = if T1 == QI2 then
        param(QI1, QI2) applyToCTranParams1(TL1, param(QI1, QI2), N1, PRL1)
      else
        param(qid(uniqueParamName(const-paramName + string(N1,10),
          PRL1)), T1)
        applyToCTranParams1(TL1, param(QI1, QI2), s(N1), PRL1)
      fi .

  op genOps : ParamList -> OpDeclSet .
  eq genOps((nil).ParamList) = none .
  eq genOps(param(QI1, QI2) PRL1) =
    (op QI1 : nil -> QI2 [none] .
    genOps(PRL1)) .

--- --- to achieve (s,p,q) --- (in mutex(s,p,q))
---   op genConstInvParams : ParamList -> QidList .
---   eq genConstInvParams((nil).ParamList) = (nil).QidList .
---   eq genConstInvParams(param(QI1, QI2) PRL1) =
---       toLowerCaseQ(QI1) genConstInvParams(PRL1) .

--- --- to achieve (s,r1) --- (in chglk(s,r1) of mutex(chglk(s,r1),p,q))
---   op genConstTranParams : TypeList Param -> QidList .
---   op genConstTranParams1 : TypeList Param Nat -> QidList .
---   eq genConstTranParams(TL1, PA1) = genConstTranParams1(TL1, PA1, 1) .
---   eq genConstTranParams1((nil).TypeList, PA1, N1) = (nil).QidList .
---   eq genConstTranParams1(T1 TL1, param(QI3, QI4), N1)
---     = if T1 == QI4 then
---         toLowerCaseQ(QI3) genConstTranParams1(TL1, param(QI3, QI4), N1)
---       else
---         qid(const-paramName + string(N1,10)) 
---           genConstTranParams1(TL1, param(QI3, QI4), s(N1))
---       fi .

--- splitting case and generate proof scores
--- first OpDeclSet is ops for init states
--- second OpDeclSet is ops for transitions
  op genPrsc : IPSGInputSpec IPSGModuleSpec 
    -> PrscList .
  op doGenPrsc : IPSGInputSpec IPSGModuleSpec 
    InvTargetList -> PrscList .
  --- op genPrscAnInv : IPSGInputSpec OpDeclSet OpDeclSet IPSGModuleSpec 
    --- InvariantTarget -> PrscList .
  op genPrscInit : IPSGInputSpec OpDeclSet IPSGModuleSpec
    InvariantTarget Nat -> PrscList .
  op genPrscInduction : IPSGInputSpec OpDeclSet IPSGModuleSpec
    InvariantTarget Nat ListLemmas -> PrscList .
  op genPrscNoInduction : IPSGInputSpec IPSGModuleSpec
    InvariantTarget Nat -> PrscList .

  eq genPrsc(INSP1, MS1) = 
    doGenPrsc(INSP1, MS1, getInputSpecInvsTarget(INSP1)) .
  
  eq doGenPrsc(INSP1, MS1, (nil).InvTargetList) = (nil).PrscList .

--- in case not applying induction
  ceq doGenPrsc(INSP1, MS1, INVT1 INVTL) =
      genPrscNoInduction(INSP1, MS1, INVT1, 1)
      doGenPrsc(INSP1, MS1, INVTL) 
    if getInvIndVar(INVT1) == pnull .

  ceq doGenPrsc(INSP1, MS1, INVT1 INVTL) =
      genPrscInit(INSP1, OPS1, MS2, INVT1, 1)
      PRSCL1
      --- doGenPrsc(INSP1, MS1, INVTL)
      doGenPrscLm(
        addLmsInv(INSP1,INVL),
        addLMs(MS2,getLmOps(LMS),getLmEqs(LMS)), 
        convLms2InvTs(INVL,getInvIndVar(INVT1)) INVTL)
    if OPS3 := getMSOps(MS1) /\
      QI := getParamType(getInvIndVar(INVT1)) /\
      OPS1 := getInitOps(QI, OPS3) /\
      OPS2 := getTransOpS(QI, OPS3) /\
      MS2 := modSpec2(
        replaceAllCondEqs(getSpecModule(MS1), getTransOpS(QI, OPS3)),
        getSpecModOps(MS1),
        getSpecModEqs(MS1)) /\
      PRSCL1 := 
        genPrscInduction(INSP1, OPS2, MS2, INVT1, 1, (nil).ListLemmas) /\
      PRSC1 := last(PRSCL1) /\
      ILS := getPrscILemma(PRSC1) /\
      LMS := getIPSGLms(ILS) /\
      INVL := lms2InvList(LMS) .

  op doGenPrscLm : IPSGInputSpec IPSGModuleSpec 
    InvTargetList -> PrscList .  
  eq doGenPrscLm(INSP1, MS1, (nil).InvTargetList) = (nil).PrscList .
  ceq doGenPrscLm(INSP1, MS1, INVT1 INVTL) =
      genPrscInit(INSP1, OPS1, MS1, INVT1, 1)
      PRSCL1
      doGenPrscLm(
        INSP2,
        MS2, 
        convLms2InvTs(INVL, getInvIndVar(INVT1)) INVTL)
      --- doGenPrscLm(
        --- INSP2,
        --- MS2, 
        --- INVTL)
    if OPS3 := getMSOps(MS1) /\
      QI := getParamType(getInvIndVar(INVT1)) /\
      OPS1 := getInitOps(QI, OPS3) /\
      OPS2 := getTransOpS(QI, OPS3) /\
      PRSCL1 := 
        genPrscInduction(INSP1, OPS2, MS1, INVT1, 1, (nil).ListLemmas) /\
      ILS := getPrscILemma(last(PRSCL1)) /\
      LMS := getIPSGLms(ILS) /\
      INVL := lms2InvList(getIPSGLms(ILS)) /\
      INSP2 := addLmsInv(INSP1,INVL) /\
      MS2 := addLMs(MS1,getLmOps(LMS),getLmEqs(LMS)) .

  eq genPrscInit(INSP1, none, MS1, INVT1, N1) = (nil).PrscList .

--- ignore base case if only generate PrSc for a transition
  ceq genPrscInit(INSP1, OPS1, MS1, INVT1, N1) = (nil).PrscList 
    if INVT1 :: InvariantTarget2 .
  ceq genPrscInit(INSP1, OPS1, MS1, INVT1, N1) = (nil).PrscList 
    if OPS1 == (none).OpDeclSet .
  ceq genPrscInit(INSP1, op QI1 : nil -> QI2 [ATTS1] . OPS1, MS1, INVT1, N1) =
    PRSCL1
    genPrscInit(INSP1, OPS1, MS1, INVT1, N1)
    if INV-NAME:Qid := getInvName(INVT1) /\
      IND-PARAM:Param := 
        applyToCIndVarParam(getInvIndVar(INVT1)) /\
      INV-PARAMS:ParamList := 
        applyToCInvParams(getInvParams(INVT1)) /\
      PRSCL1 := loopGenPrsc(prsc-init(
        fmod qid(const-modName + string(INV-NAME:Qid) + "-0") is 
          protecting getInputSpecMod(INSP1) .
          sorts none .
          none
          genOps(IND-PARAM:Param
              INV-PARAMS:ParamList
              applyToCTranParams((nil).TypeList, IND-PARAM:Param, 
                INV-PARAMS:ParamList))
          none --- mb
          none --- eqs
        endfm,
        INV-NAME:Qid,
        QI1,
        INV-PARAMS:ParamList,
        IND-PARAM:Param,
        MS1
      ), MS1, INSP1) .

  eq genPrscInduction(INSP1, none, MS1, INVT1, N1, LMS) = (nil).PrscList .

--- ignore other cases if only generate PrSc for a transition
  ceq genPrscInduction(INSP1, op QI1 : TL1 -> QI2 [ATTS1] . OPS1, MS1, 
    invariantTarget2(INV1, PA1, QI3), N1, LMS) = 
      genPrscInduction(INSP1, OPS1, MS1, invariantTarget2(INV1, PA1, QI3), N1, LMS)
    if QI1 =/= QI3 .

--- in case no induction
  ceq genPrscNoInduction(INSP1, MS1, INVT1, N1) = 
      checkComplicated(prsc2(
        fmod qid(const-modName + string(INV-NAME:Qid) + "-" + string(N1,10)) is 
          protecting getInputSpecMod(INSP1) .
          sorts none .
          none
          genOps(INV-PARAMS:ParamList)
          none --- mb
          none --- eqs
        endfm,
        INV-NAME:Qid,
        INV-PARAMS:ParamList,
        MS1
      ), MS1, INSP1)
    if
      INV-NAME:Qid := 
        getInvName(INVT1) /\
      INV-PARAMS:ParamList := 
        applyToCInvParams(getInvParams(INVT1)) .

  ceq genPrscInduction(INSP1, op QI1 : TL1 -> QI2 [ATTS1] . OPS1, MS1, INVT1, N1, LMS) = 
    PRSCL1
      genPrscInduction(INSP2, OPS1, MS1, INVT1, s(N1), getIPSGLms(ILS)) --- can be disable for simple debug
    if INV-NAME:Qid := getInvName(INVT1) /\
      IND-PARAM:Param := 
        applyToCIndVarParam(getInvIndVar(INVT1)) /\
      INV-PARAMS:ParamList := 
        applyToCInvParams(getInvParams(INVT1)) /\
      PRSCL1 := checkComplicated(prsc1(
        fmod qid(const-modName + string(INV-NAME:Qid) + "-" + string(N1,10)) is 
          protecting getInputSpecMod(INSP1) .
          sorts none .
          none
          genOps(IND-PARAM:Param
              INV-PARAMS:ParamList
              applyToCTranParams(TL1, IND-PARAM:Param,
                INV-PARAMS:ParamList))
          none --- mb
          none --- eqs
        endfm,
        INV-NAME:Qid,
        QI1,
        INV-PARAMS:ParamList,
        applyToCTranParams(TL1, IND-PARAM:Param, INV-PARAMS:ParamList),
        IND-PARAM:Param,
        MS1,
        ipsglemmas(LMS, size(LMS))
      ), MS1, INSP1) /\
      ILS := getPrscILemma(last(PRSCL1)) /\
      INSP2 := addLmsInv(INSP1,lms2InvList(getIPSGLms(ILS))) [print "--> Finish " QI1] .

***(
  check if a very complicated term, conducting case splitting first,
  otherwise asking metaReduce directly
)
  op checkComplicated : IPSGProofScore IPSGModuleSpec IPSGInputSpec -> PrscList .
  ceq checkComplicated(PRSC1, MS1, INSP1) =
    if isComplicated2(TE2) then
      --- if countNodes(TE2) < 1 then
        --- handleCS(PRSC1, MS1, INSP1, TMOD:Module, TE)
      --- else 
        handleCS(PRSC1, MS1, INSP1, TMOD:Module, TE2)
      --- fi
    else
      checkComplicated2(PRSC1, MS1, INSP1)
    fi 
  if TMOD:Module := tempMod2(getPrscModule(PRSC1), MS1, getPrscILemma(PRSC1)) /\
    --- TE3 := getPrscInvIndHyp(PRSC1) /\
    TE4 := getPrscInvIndConl(PRSC1) /\
    --- TE := getTerm(metaReduce(TMOD:Module, TE3)) /\
    TE2 := getTerm(metaReduce(TMOD:Module, TE4)) .

  op checkComplicated2 : IPSGProofScore IPSGModuleSpec IPSGInputSpec -> PrscList .
  ceq checkComplicated2(PRSC1, MS1, INSP1) =
    if isComplicated2(TE) then
        handleCS2(PRSC1, MS1, INSP1, TMOD:Module, TE)
    else
      loopGenPrsc(PRSC1, MS1, INSP1)
    fi 
  if TMOD:Module := tempMod2(getPrscModule(PRSC1), MS1, getPrscILemma(PRSC1)) /\
    TE3 := getPrscInvIndHyp(PRSC1) /\
    TE := getTerm(metaReduce(TMOD:Module, TE3)) .

  op handleCS : IPSGProofScore IPSGModuleSpec IPSGInputSpec Module Term -> PrscList .
  eq handleCS(PRSC1, MS1, INSP1, TMOD:Module, TE) = 
    --- split by term
    if extractIfCondsT(TE) == empty then
      checkCompCS(PRSC1,
        chooseStrategyCS(PRSC1,extractSplitCasesT(TE)),TMOD:Module,MS1,INSP1)
    else
      --- split by if else condition
      checkCompCS(PRSC1,
        chooseStrategyCS(PRSC1,extractIfCondsT(TE)),TMOD:Module,MS1,INSP1)
    fi .

  op handleCS2 : IPSGProofScore IPSGModuleSpec IPSGInputSpec Module Term -> PrscList .
  eq handleCS2(PRSC1, MS1, INSP1, TMOD:Module, TE) = 
    --- split by term
    if extractIfCondsT(TE) == empty then
      checkCompCS(PRSC1,
        chooseStrategyCS(PRSC1,extractSplitCasesT(TE)),TMOD:Module,MS1,INSP1)
    else
      --- split by if else condition
      checkCompCS(PRSC1,
        chooseStrategyCS(PRSC1,extractIfCondsT(TE)),TMOD:Module,MS1,INSP1)
    fi .

--- loop split case (split one original fragment -> mutilple fragments)
  op loopGenPrsc : IPSGProofScore IPSGModuleSpec IPSGInputSpec -> PrscList .
  ceq loopGenPrsc(PRSC1, MS1, INSP1) =
  --- true
  if TE == 'true.Bool then
      --- addComment2Prsc(PRSC1, getName(TE))
      handleLeafTrue(PRSC1)
    else
      --- false
      if TE == 'false.Bool then
        --- addComment2Prsc(PRSC1, getName(TE))
        handleLeafFalse(PRSC1, MS1, INSP1)
      else
        --- split by term
        if extractIfCondsT(TE) == empty then
          loopGenPrscCS(PRSC1,
            chooseStrategyCS(PRSC1, extractSplitCasesT(TE)),TMOD:Module,MS1,INSP1)
        else
          loopGenPrscCS(PRSC1,
            chooseStrategyCS(PRSC1, extractIfCondsT(TE)),TMOD:Module,MS1,INSP1)
        fi
      fi
    fi 
  if TMOD:Module := tempMod2(getPrscModule(PRSC1), MS1, getPrscILemma(PRSC1)) /\ 
    TE := getTerm(metaReduce(TMOD:Module, getPrscMetaReduceCmd(PRSC1))) .

  op chooseStrategyCS : IPSGProofScore TermList -> Term .
  eq chooseStrategyCS(PRSC1, TEL) =
    if getEqs(getPrscModule(PRSC1)) == none then
      headTL(TEL)
    else
      chooseTermCS(TEL)
    fi .

  op handleLeafTrue : IPSGProofScore -> IPSGProofScore .
  op handleLeafFalse : IPSGProofScore IPSGModuleSpec IPSGInputSpec -> PrscList .
  op loopGenPrscCS : IPSGProofScore Term Module IPSGModuleSpec IPSGInputSpec 
    -> PrscList .
  op checkCompCS : IPSGProofScore Term Module IPSGModuleSpec IPSGInputSpec 
    -> PrscList .
  op checkComp2CS : IPSGProofScore Term Module IPSGModuleSpec IPSGInputSpec 
    -> PrscList .

  ceq loopGenPrscCS(PRSC1, TE2, TMOD:Module, MS1, INSP1) 
    = PRSCL1
      loopGenPrsc(updatePrsc(PRSC1,
        makeEqF(TE2,TMOD:Module,getPrscModule(PRSC1)),2,ILS),MS1,INSP2)
  if PRSCL1 := loopGenPrsc(addEquation2Prsc(PRSC1,
            makeEqT(TE2,TMOD:Module,getPrscModule(PRSC1)),1), MS1, INSP1) /\
    ILS := getPrscILemma(last(PRSCL1)) /\
    INSP2 := addLmsInv(INSP1,lms2InvList(getIPSGLms(ILS))) .

  ceq checkCompCS(PRSC1, TE, TMOD:Module, MS1, INSP1) 
    = PRSCL1
      checkComplicated(updatePrsc(PRSC1,
        makeEqF(TE,TMOD:Module,getPrscModule(PRSC1)),2,ILS),MS1,INSP2)
  if PRSCL1 := checkComplicated(addEquation2Prsc(PRSC1,
            makeEqT(TE,TMOD:Module,getPrscModule(PRSC1)),1), MS1, INSP1) /\
    ILS := getPrscILemma(last(PRSCL1)) /\
    INSP2 := addLmsInv(INSP1,lms2InvList(getIPSGLms(ILS))) .

  ceq checkComp2CS(PRSC1, TE, TMOD:Module, MS1, INSP1) 
    = PRSCL1
      checkComplicated2(updatePrsc(PRSC1,
        makeEqF(TE,TMOD:Module,getPrscModule(PRSC1)),2,ILS),MS1,INSP2)
  if PRSCL1 := checkComplicated(addEquation2Prsc(PRSC1,
            makeEqT(TE,TMOD:Module,getPrscModule(PRSC1)),1), MS1, INSP1) /\
    ILS := getPrscILemma(last(PRSCL1)) /\
    INSP2 := addLmsInv(INSP1,lms2InvList(getIPSGLms(ILS))) .

  eq handleLeafTrue(PRSC1) = addComment2Prsc(PRSC1, 'true) .
  eq handleLeafFalse(PRSC1, MS1, INSP1) 
    = if tryToUseLemma then
        handleFalseCase(PRSC1, MS1, INSP1)
      else
        addComment2Prsc(PRSC1, '\r 'false '\o)
      fi .
endm